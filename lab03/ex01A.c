/*
Exercise 01 (version A, B, C, ad D)
I/O: Blocking, non-blocking, multiplexed, asynchronous
------------------------------------------------------

A parent process P generates two children processes C1 and C2.
C1 and P communicate through a pipe p1 and C2 and P communicate
through a pipe p2.
- Process C1:
  every WAIT_TIME_1 seconds generates a string of STR_SIZE small alphabetic
  letters at most (i.e., from 1 to STR_SIZE letters) and writes the string
  into pipe p1.
  Overall C1 generates and writes on pipe p1, STR_NUM strings of variable length.
- Process C2:
  does the same things done by C1 but it waits for WAIT_TIME_2
  seconds, and it writes the strings into pipe p2.
- Process P:
  reads the strings coming from the two pipes (p1 and p2), converts
  them in capital letters, and displays them on standard output.

Note that:
- WAIT_TIME_1, WAIT_TIME_2, STR_NUM, and STR_SIZE are predefined
  constant values.
- Strings are randomly generated (composed by only small alphabetic
  letters) of variable length.

Write 4 versions of the program:

A. Using blocking I/O system calls.
B. Using non-blocking I/O system calls.
C. Using multiplexing I/O.
D. Using asynchronous I/O.

Analyze and compare the outputs generated by the different versions of
the program.

Suggestion
----------

Processes C1 and C2 write strings of variable *length* on pipes p1 and
p2, respectively.
To let the parent process P to read these strings "synchronously", it is
better to use the following simple communication protocol:
- C1 and C2, before writing the string onto the pipe, write its length,
  i.e., a single integer value.
- P reads the integer value n and then it reads exactly n characters
  (thus it synchronizes its reading operation with the writing operation
  on the other end of the pipe).
The alternative would be to read from the pipe character-by-character
until finding the termination character of each string ('\0').
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define WAIT_TIME_1 1
#define WAIT_TIME_2 2
#define STR_SIZE 10
#define STR_NUM 3

int p1[2], p2[2];

// Returns size-1 characters + \0
// minimum size = 1
void rand_string(char *str, size_t size)
{
  const char charset[] = "abcdefghijklmnopqrstuvwxyz";
  if (size)
  {
    for (size_t n = 0; n < size - 1; n++)
    {
      int key = rand() % (int)(sizeof charset - 1);
      str[n] = charset[key];
    }
    str[size - 1] = '\0';
  }
}

void child1()
{
  int randSize, i;
  char randString[STR_SIZE];

  for (i = 0; i < STR_NUM; i++)
  {
    sleep(WAIT_TIME_1);

    randSize = (rand() % STR_SIZE) + 1; // From 1 to STR_SIZE
    rand_string(randString, randSize);

    write(p1[1], randString, randSize);
  }
}

void child2()
{
  int randSize, i;
  char randString[STR_SIZE];

  for (i = 0; i < STR_NUM; i++)
  {
    sleep(WAIT_TIME_2);

    randSize = (rand() % STR_SIZE) + 1; // From 1 to STR_SIZE
    rand_string(randString, randSize);

    write(p2[1], randString, randSize);
  }
}

void parent()
{
  char c;
  int i;

  for (i = 0; i < STR_NUM; i++)
  {
    printf("P1: ");
    while (1)
    {
      read(p1[0], &c, sizeof(char));
      if (c == '\0')
      {
        printf("\n----------\n");
        break;
      }
      else
      {
        c -= 32;
        printf("%c", c);
      }
    }

    printf("P2: ");
    while (1)
    {
      read(p2[0], &c, sizeof(char));
      if (c == '\0')
      {
        printf("\n----------\n");
        break;
      }
      else
      {
        c -= 32;
        printf("%c", c);
      }
    }
  }
}

int main(int argc, char *argv[])
{
  setbuf(stdout, 0);

  pipe(p1);
  pipe(p2);

  if (fork())
  {
    // Parent
    if (fork())
    {
      // Parent
      parent();
    }
    else
    {
      // Child 2
      child2();
    }
  }
  else
  {
    // Child 1
    child1();
  }
  return 0;
}